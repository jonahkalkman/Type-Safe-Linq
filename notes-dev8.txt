imperative
    what matters is the final state
x = 1 + 1 eval_i(x = 1, S) => (done, y = 1, S') S' = S(x = 1)
y = 1

functional - stateless
    what matters is final expression
eval_f(P) => P'
P
x = 1
y = x + 1

eval_f(P) => y = 1 + 1

lambda calculus = a language
    what matters is the new program, output program

eval expr => expr == always return an expr
expr = variable || abstraction || application

variable
-------------
eval x => x

abstraction
-------------
eval(fun x => t) => (fun x => t)

application - substitution rule
--------------------------------
u is input for the func

eval((func x => t) u) => t[x => u]



examples:
------------
        x       t            u
eval (fun x => (fun y => x))(fun x => x) =>
    (fun y => x)[x => (fun x => x)] =>
    (fun y => fun x => x)

replace all with input u


// Infinite loop
-----------------------
eval (fun x => xx)(fun x => xx) =>
    xx[x => (fun x => xx)] =>
    fun(x => xx)(fun x => xx)

// 5 and 6 are input
(((fun x => ((fun y => x + y) 5)) 6) =>
    ((fun y => x + y)5)[x => 6] =>
        (fun y => 6 + y) 5 =>
            (6 + y)[y => 5] =>
                6 + 5 =>
                    11

compact fun delcaration:
fun x => fun y => fun z => .... ==(is equal to)= fun x y z => ...

shadowing
keep replacing until find variable or if find fun that has same input name as variable you are replacing
--------------
(fun x1 y1 x2 => x2)(5) =>
(fun(y1 x2 => x2)[x1 => 5] =>
(fun y1 x2 => x2)



f# - console application - can link f# with c# for math problems
---------------------------

let min =
    let x = 5
    let sum = fun x y => x + y
    let y = 7
    x

    (fun x => fun( y -> x) 7) 5


let sum = fun x => fun y => x + y
let inc = sum(1)
printfn "%d" (inc(5))












curry vs  uncurry =  inputs are provided at different moments
---------------
uncurry:
def sum(x,y):
    return x +y

curry:
def sum(x):
    return lambda y: x + y

def inc():
    return sum(1)

use curry:
----------
five = (sum(2))(3)
first do sum fun and ouput expects another input so give 3 after it


example:
------------
(\y => ((\x => x)3))5
((\x => x)3))[y:=5]
x[x:=3]
3

(\incr => incr(5)) (\x => x + 1)
(\incr => incr(5))[incr:= (\x => x + 1)]
(\x => x + 1)(5)
(\x => x + 1)[x:=5]
5 + 1
6
let main =
    let incr = fun x => x + 1
    incr(5)

    if(incr(5) > 0) then
        6
    else
        5


    let rec sum_to_n =
        fun n => if(n <= 0) then 0
        else n + sum_to_n(n - 1)

    let rec sum_to_n2 =
        fun n =>
            let rec sum_to_n_AUX =
                fun(n, acc) =>
                    if(n <= 0) then acc
                    else sum_to_n_AUX(n - 1), n + acc
            sum_to_n_AUX(n, 0)

    printfn "%d" (incr(5))

    allNumber(4) => '01234'
    let rec allNumber =
    fun n =>
    if n <= 0 then string n
    else allNumber(n -1) + string n



